Quando precisamos fazer testes, e temos uma classe que depende de outras classes para o funcionamento, principalmente utilizando o:

private FINAL ClasseX nomeDaVariavel

Esse FINAL utilizado, impede que haja um construtor default, aquele vazio, que n√£o necessita de argumentos para ser inicializado.

Dessa forma, quando vamos mockar as depend√™ncias de classes de valida√ß√£o na de servi√ßo, por exemplo, ocorre diversos erros, visto que, n√£o √© necessariamente colocar @Mock ou @InjectMocks para se ter um funcionamento correto das valida√ß√µes.

No nosso caso, para resolver os erros acusados nos testes, foi necess√°rio utilizar uma nova anota√ß√£o @Spy, que "espiona" o comportamento da classe que tem essa anota√ß√£o.

Por√©m, quando usamos o @Spy, ele necessita ter um construtor vazio para conseguir fazer o seu trabalho, e quando temos uma classe X que tem atributos private FINAL, isso n√£o √© poss√≠vel, pois, construtores vazios n√£o s√£o permitidos nestes casos.

A forma que encontramos de resolver isso, ap√≥s pesquisarmos, foi dessa forma:

-> Mesmo tendo o @ExtendWith(MockitoExtension.class) no in√≠cio da classe, √© necess√°rio instanciar manualmente os elementos necess√°rios para que os testes n√£o falhem:

    @Mock
    private CompradorRepository compradorRepository;

    //classe precisa ser mocada no BeforeEach manualmente para evitar erros compila√ß√£o do teste
    private CompradorValidator compradorValidator;

    @Spy
    private CPFValidator cpfValidator;

    //classe precisa ser mocada no BeforeEach manualmente para evitar erros compila√ß√£o do teste
    private CompradorServiceImpl compradorService;

    @BeforeEach
    void setUp() {
        compradorValidator = Mockito.spy(new CompradorValidator(cpfValidator)); //adiciona a anota√ß√£o Spy no compradorValidator e inclui o param do construtor da classe
        compradorService = new CompradorServiceImpl(compradorRepository, compradorValidator); //moca as inst√¢ncias necessarias para o funcionamento do service
    }

-> esse setUp, inicializa os mocks ao percorrer cada m√©todo validador na classe de testes, ele est√° manualmente injetando os mocks nas classes que necessitam, e assim, conseguimos testar os m√©todos de uma forma mais pr√≥xima da real.

-> LEMBRA DISSO QUANDO HOUVER M√âTODOS QUE DEPENDEM DE OUTROS M√âTODOS E USAM O PRIVATE FINAL, O COMPORTAMENTO DE AJUSTE DOS TESTES SER√Å BEM SEMELHANTE!

----------------------------------------------------------------------------------------------------

üîç Por que isso funciona t√£o bem?
Porque voc√™:

Mockou o CPFValidator com @Spy, ent√£o consegue monitorar/comportar a l√≥gica se quiser.

Criou o spy manualmente do CompradorValidator, passando a depend√™ncia dele (cpfValidator), coisa que o Mockito n√£o consegue fazer sozinho com @Spy em campo.

Instanciou a CompradorServiceImpl de forma direta, evitando depender do @InjectMocks, que fica limitado quando as depend√™ncias tamb√©m t√™m depend√™ncias.

Essa abordagem tamb√©m te d√° liberdade pra:

Verificar intera√ß√µes com o validator se quiser (verify(compradorValidator).validateAllDataRegistration(...))

Testar com CPF real ou manipulado (v√°lido, inv√°lido, vazio etc.)